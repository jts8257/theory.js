<h4> (4.4) 함수 호출과 this </h4>

<h5> [4.4.1] arguments 객체 </h5>
<p> C와 같은 엄격한 언어와 달리, JS는 함수를 호출할 때 함수 형식에 맞춰 인자를 넘기지 않더라도 에러가 발생하지 않는다. </p>

```
// 인자 형식을 맞추지 않은 함수

function func(arg1, arg2) {
    console.log(arg1, arg2);
}

func(); // undefined undefined
func(1); // 1 undefined
func(1,2); // 1 2
func(1,2,3); // 1 2
```

<p> JS의 이러한 특징 때문에 함수 코드 작성할 때, 
  런타임 시에 호출된 인자의 개수를 확인하고 이에 따라 동작을 다르게 해줘야 할 경우가 있다.
  이를 가능케 하는 것이 바로 arguments 객체다. arguments 객체는 함수를 호출할 때 넘긴 인자들이 배열 형태로 저장된 객체인데,
  함수를 호출할때 인수들과 함께 암묵적으로 arguments 객체가 함수 내부로 전달된다.
  특이한 점은 이 arguments 객체가 <b>유사 배열 객체</b>라는 점이다.
</p>

```
// arguments 객체 확인
function add(a, b) {
    console.dir(arguments);
    return a + b;
}

console.log(add(1)); // NaN
console.log(add(1, 2)); // 3
console.log(add(1, 2, 3)); // 3

          /* console.log(add(1,2)) 경우만 보면 
          Arguments(2)
          0: 1
          1: 2
          callee: ƒ add(a, b)
          length: 2
          Symbol(Symbol.iterator): ƒ values()
          __proto__: Object
          */
```

<p> Arguemnt(n) 에서 n은 인자 갯수를 나타낸다. 이 n에 따라 length 가 정해진다. 즉, length는 인자의 개수다. 
  callee 는 현재 실행중인 함수의 참조값을 의미한다. arguments 는 비록 length 프로퍼티가 있지만, 유사 배열 객체이지
  배열이 아니기 때문에 표준 배열 메소드를 이용할 수 없다. <b>하지만 call 과 apply 매소드를 이용하면 가능하다.</b>
</p>

<p> argument 객체는 매개변수 개수가 정확하게 정해지지 않은 함수를 구현하거나, 
  전달된 인자의 개수에 따라 서로 다른 처리를 해줘야 하는 함수를 개발하는 데 유용하게 사용할 수 있다.</p>
  
```
function sum() {
    var result = 0;
    
    for(var i = 0 ; i < argument.length ; i++) {
        result += argument[i];
    };
    return result;
};

console.log(sum(1,2,3)); // 6
console.log(sum(1,2,3,4,5,6,7,8,9)); // 45
```

<h5> [4.4.2] 호출 패턴과 this 바인딩</h5>
<p> <b>JS에서는 함수 호출시 argument 객체 뿐만 아니라 this 인자가 암묵적으로 함수 내부로 전달된다.</b>
    특히 this는 JS의 핵심 개념이다. this가 어려운 이유는 JS의 여러 가지 <b>함수가 호출되는 방식(호출 패턴)</b>에 따라 <b>this가 다른 객체를 참조(this 바인딩)</b>하기 때문이다. 여기서는 함수 호출 패턴과 해당 패턴에 따른 this 바인딩을 알아보자.</p>


<h5> [4.4.2.1] 객체의 매서드 호출과 this 바인딩</h5>
<p> 객체의 프로퍼티가 함수일 경우, 이 함수를 매서드라고 부른다. 이러한 <b>매서드를 호출할 때, 매서드 내부 코드에서 사용된 this는 해당 매서드를 호출한 객체로 바인딩된다. </b> </p>

```
var obja = {
    name: 'foo',
    sayName: function() {
        console.log(this.name);
    }
};

var objb = {
    name: 'bar'
};

objb.sayName = obja.sayName;
obja.sayName; // foo;
objb.sayName; // bar;
```
<h5> [4.4.2.2] 함수 호출과 this 바인딩</h5>
<p> JS에서 함수를 호출하면, 해당 함수 내부 코드에서 사용된 this는 <b>전역 객체</b>에 바인딩 된다.
만약 브라우저에서 JS를 실행하는 경우 전역 객체는 window 객체(Node.js에서는 global) 가 된다. JS의 모든 전역 변수들은 사실 이러한 전역 객체의 프로퍼티들이다. 따라서 전역변수는 전역 객체의 프로퍼티로도 접근할 수 있다.</p>

<p> [따로 알아본 사실]<br>
    console.dir(window); 를 해보면 이미 정의되어져 있는 함수들을 확인할 수 있다.<br>
    window의 프로토타입(부모 객체)는 window다 </p>
    
```
// 전역 객체와 전역 변수의 관계

var foo = "I'm foo"; // 전역 변수 선언
console.log(foo); // I'm foo
console.log(window.foo); // I'm foo
```


<p> 전역 객체의 프로퍼티로서 전역 변수에 접근이 가능하므로, this 바인딩을 활용하여 다음과 같이 출력이 가능하다. </p>

```
// 함수 호출시 this 바인딩

var test = 'This is test';
console.log(window.test); // This is test

var sayFoo = function() {
    console.log(this.test);
};

sayFoo(); // This is test
```

<p> 함수에서 this를 사용하는 경우 전역객체인 window를 호출하는 경우는 내부 함수에서도 유지되므로 주의해야한다. </p>


```
// 내부 함수에서 this 사용

var value = 100;

var obj = {
    value: 1,
    func1: function() {
        this.value += 1;
        console.log('func1() called - this.value : ' + this.value);
    // func2() 내부 함수    
        func2 = function () {
            this.value += 1;
            console.log('func2() called - this.value : ' + this.value);
        // func3() 내부 함수    
            finc3 = function () {
                this.value += 1;
                console.log('func3() called - this.value : ' + this.value);
            }
            func3();
        }
        func2();
   }
};
obj.func1();
```

<p> 이 예제는 func1이 호출되고, func2가 호출되고, func3가 호출되는 구조를 가지고 있다. 이때 객체의 메소드인 func1의 this는 obj와 바인딩 되지만, <b> 내부 함수인 func2()와 func3()는 전역 객체인 window와 바인딩 된다.</b> 따라서 출력 결과는 다음과 같다. </p>

```
func1() called - this.value : 2
func2() called - this.value : 101
func3() called - this.value : 102
```

<p> 이러한 한계를 극복하기 위해서는 부모 함수(func1())의 this를 내부 함수가 접근 가능한 다른 변수에 저장하는 방법을 
    이용할 수 있다. <b> 관례상 this값을 저장하는 변수의 이름을 that이라고 짓는다. </b> </p>
    
```
// 부모 함수 this를 that으로 해서 내부 함수에 전달

var value = 100;

var obj = {
    value: 1,
    func1: function() {
        var that = this;
        
        this.value += 1;
        console.log('func1() called - this.value : ' + this.value);
    // func2() 내부 함수    
        func2 = function () {
            that.value += 1;
            console.log('func2() called - this.value : ' + that.value);
        // func3() 내부 함수    
            finc3 = function () {
                that.value += 1;
                console.log('func3() called - this.value : ' + that.value);
            }
            func3();
        }
        func2();
   }
};
obj.func1();

/* 출력값
func1() called - this.value : 2
func2() called - this.value : 3
func3() called - this.value : 4
```

<p> 내부 함수는 부모 함수의 변수에 접근할 수 있기 때문에, 부모함수에서 that으로 정의된 변수를 내부 함수에서 그대로 사용할 수 있다. func3()역시 func1()의 변수에 접근하였다. </p>

<p> JS에서는 이와 같은 this 바인딩의 한계를 극복하려고, this 바인딩을 명시적으로 할 수 있도록 call과 apply 메서드를 제공하는데, 이는 4.4.2.4에서 자세히 소개된다. jQuery, underscore.js 등과 같은 라이브러리는 bind라는 이름의 메서드를 통해 사용자가 원하는 객체를 this에 바인딩 할 수 있는 기능을 제공하고 있다. 이 bind 메소드는 7장에서 소개한다. </p>

<h5> [4.4.2.3] 생성자 함수를 호출할 때 this 바인딩</h5>
<p> 이번에는 생성자 함수를 이용한 객체 방법을 알아보자. </p>
<p> JS의 생성자 함수는 말 그대로 JS의 객체를 생성하는 역할을 한다. 하지만 C++이나 JAVA와 같은 객체지향 언어에서의 생성자 함수의 형식과는 다르게 그 형식이 정해져 있는 것이 아니라, <b>기존 함수에 new ㅇ녀산자를 붙여서 호출하면 해당 함수는 생성자 함수로 동작한다. </b> 이는 반대로 생각하면 일반 함수에 new를 붙여 호출하면 원치 않는 생성자 함수처럼 동작할 수 있다. 이러한 이유로 대부분의 JS가이드에서는 <b>함수 이름의 첫 글자를 대문자</b>로 쓰도록 하고 있다.</p>

<p>  </p>

<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
<p> </p>
