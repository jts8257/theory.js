<h4> (4.3) 함수의 다양한 형태 </h4>

<h5> [4.3.1] 콜백 함수 </h5>
<p> 콜백 함수는 명시적으로 호출하는 함수가 아니라, 개발자는 단지 함수를 등록하기만 하고, 
  어떤 이벤트가 발생했거나 특정 시점에 도달했을 때 시스템에서 호출되는 함수를 말한다. 
  또한 특정 함수의 인자로 념겨서, 코드 내부에서 호출되는 함수 또한 콜백 함수가 될 수 있다.
  익명함수의 대표적인 용도가 바로 콜백 함수이다. </p>
  
<p> 대표적인 콜백 함수의 사용 예가 JS의 이벤트 핸들러 처리이다. 웹 페이지가 로드되거나 키보드가 입력되는 등의 DOM 
  이벤트가 발생할 경우, 브라우저는 정의된 DOM 이벤트에 해당하는 이벤트 핸들러를 실행시킨다. 만약 이러한 이벤트 핸들러에
  콜백 함수를 등록해뒀다면, 콜백 함수는 이벤트가 발생할 때마다 브라우저에 의해 실행되게 된다. </p>

<p> 다음의 예시를 보자, window.onload는 이벤트 핸들러로서, 웹 페이지의 로딩이 끝나는 시점에 load 이벤트가 발생하면 실행된다.
  예제에서는 window.onload 이벤트 핸들러를 익명 함수로 연결했다. 따라서 익명 함수가 콜백 함수로 등록된 것이다. </p>

```
<!DOCTYPE html>
<html>
    <body>
        <script>
            window.onload = function () {
                alert('this is the callback function');
            };
        </script>
    </body>
</html>
```

<h5> [4.3.2] 즉시 실행 함수 </h5>
<p> 함수를 정의함과 동시에 바로 실행하는 함수를 즉시 실행함수라고 한다. 이 함수도 익명 함수를 응용한 형태이다. </p>

```
(function (name) {
  console.log('this is the immediate function --> ' + name);
})('foo');

// 출력값 : this is the immediate function --> foo
```

<p> 즉시 실행 함수를 만드는 방법은 간단하다. 함수 리터럴을 괄호()로 둘러싼다. 이때 함수 이름이 있든 없든 상관없다.
그런 다음 함수가 바로 호출되게 () 괄호 쌍을 추가한다. 이때 괄호 안에 값을 추가해 즉시 실행 함수의 인자로 넘길 수 있다.
예제의 경우는 ('foo')로 즉시 실행 함수를 호출했으며, 이때 'foo'를 인자로 넘겼다. </p>

<p> 이러한 즉시 실행 함수는 같은 함수를 다시 호출할 수 없다. 따라서 즉시 실행 함수의 이러한 특징을 이용하여, 최초 한 번의 실행만을 필요로 하는 초기화 코드 부분 등에 활용된다. </p>

<p> 또한 즉시 실행 함수는 jQuery와 같은 JS라이브러리나 프레임워크 소스들에서 사용된다. jQuery 소스 코드를 살펴보면 소스의 시작 부분과 끝 부분이 다음 에제와 같이 즉시 실행 함수 형태로 구성되어 있음을 확인할 수 있다. </p>

```
(function( window, undefined) {
......
})( window );
```

<p> 이렇듯 JS 라이브러리에서 즉시 실행 함수를 사용하는 이유는 <b> JS변수 유효 범위 특성</b> 때문이다. <br>
JS에서는 함수 유효 범위를 지원한다. <br>
  기본적으로 JS는 변수를 선언할 경우 프로프램 전체에서 접근할 수 있는 전역 유효 범위를 가지게 된다. 그러나 함수 내부에서 정의된 매개변수와 변수들은 함수 코드 내부에서만 유요할 뿐 함수 밖에서는 유요하지 않다. </p> 
  
<p> 따라서 라이브러리 코드를 즉시 실행 함수 내부에 정의해두게 되면, 라이브러리 내의 변수들은 함수 외부에서 접근할 수 없다. 따라서 즉시 실행 함수로 라이브러리 코드를 감싸게 되면, 전역 네임 스페이스를 더럽히지 않으므로, 다른 라이브러리들과 동시에 로드 되더라도 라이브러리간 변수 이름 충돌 문제를 방지할 수 있다. </p>


<h5> [4.3.3] 내부 함수 </h5>
<p> JS에서는 함수 코드 내부에서도 다시 함수 정의가 가능하다. 이렇게 함수 내부에 정의된 함수를 <b>내부 함수</b>라고 부른다. 내부 함수는 클로저를 생성하거나 부모 함수 코드에서 외부에서의 접근을 막고 독립적인 헬퍼 함수를 구현하는 용도 등으로 사용한다. </p>

```
function parent() {
  var a = 100;
  var b = 200;
  
  function child() {
    var b = 300;
    
    console.log(a);
    console.log(b);
  }
  child();
}

parent(); // 출력값: 100 300
child(); // 출력값: Uncaught ReferenceError: child is not defined
```

<p> 주목해야 하는 점은 parent()를 호출했을때, 내부 함수 child에 의해 변수 a와 b를 출력하는데, child 내부에서 a가 정의되지 않았음에도, 제대로된 값이 출력된다는 점이다. 이는 내부 함수가 부모 함수의 변수 a값에 접근할 수 있다는 것을 의미한다. 
  이것이 가능한 이유는 JS의 <b>스코프 체이닝</b> 때문이다. 일단은 내부 함수는 자신을 둘러싼 외부 함수의 변수에 접근 가능하다는 정도만 기억하자. </p>
  
<p> 함수 스코프 외부에서 함수 내부로 접근하는 것은 불가능하지만, 스코프 체이닝 덕분에 내부 함수가 부모 함수로 접근하는 것은 가능하다. <b>하지만 부모 함수 외부에서도 내부 함수를 호출할 수 있는 경우</b>가 있다. 가령, 부모 함수에서 내부 함수를 외부로 리턴하면, 부모 함수 밖에서도 내부 함수를 호출하는 것이 가능하다. </p>

```
function parent() {
    var a = 100;
    var child = function () {
        console.log(a);
    };
    return child;
}

var inner = parent();
inner(); // 출력값: 100
```

<p> 부모함수는 내부에서 child 변수에 내부 함수를 정의하고 (따라서 함수 참조값을 갖는), 해당 함수 변수를 반환한다. 이러한 parent() 함수를 함수 변수 inner 에 할당하게 되면, inner 변수에 child함수 변수 값이 리턴된다. child 함수 변수는 내부 함수의 참조 값이 있으므로, 결국 inner 변수는 child 함수 변수와 동일한 함수 참조값을 갖게 된다, 그러한 이유로 결국 100이 출력되게 된다. </p>

<p> 이와 같이 실행이 끝난 parent() 와 같은 부모 함수 스코프의 변수를 참조하는 inner()와 같은 함수를 <b>클로저</b>라고 한다. </p> 

<p> [발견한 내용]<br>
  parent()() 를 실행하게 되면 역시 100이 출력된다. 이는 () 연산자가 함수 스코프 {} 를 한꺼풀 벗기고, 내부 코드를 실행하는 역할을 하기 때문이다. </p> 

<h5> [4.3.4] 함수를 리턴하는함수 </h5>
<p> JS에서 함수는 일급 객체이므로 함수가 함수 자체를 반환할 수 있다. 이러한 특징을 이용하면 다양한 활용이 가능해진다. 
  함수를 호출함과 동시에 다른 함수로 바꾸거나, 자기 자신을 재정의하는 함수를 구련할 수 있다. </p>
  
```
// 자신을 재정의하는 함수 
var self = function () {
    console.log('a');
    return function () {
        console.log('b');
  };
};
self = self(); // a
self(); // b
```

<p> 처음 self()가 호출되었을 때 'a' 가 출력되는데, 동시에 다시 self 변수에 self() 함수 리턴값을 할당하여 새로운 함수를 정의한다. 따라서 다시 self()를 호출했을 때는 'b'가 출력된다. </p>

