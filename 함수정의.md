<h4>(4.1)함수 정의</h4>
<p> JS에서 함수를 생성하는 방법은 3가지다.</p>

* 함수 선언문(함수 리터럴)
* 함수 표현식(변수에 할당)
* Function() 생성자 함수

<h5>[4.1.1] 함수 리터럴</h5>
<p> 함수도 일반 객체처럼 값으로 취급된다. 때문에 객체 리터럴 방식으로 일반 객체를 생성할 수 있는 것 처럼, JS에서는 함수 리터럴을 이용해 함수를 생성할 수 있다. 함수 선언문, 표현식 모두 리터럴 방식으로 함수를 생성한다. </p>

```
function add (x, y) {
  return x + y;
}
```
<p> JS의 함수 리터럴 방식은 크게 4부분으로 나뉜다. </p>

* function 키워드: JS의 함수 리터럴은 function 키워드로 시작한다.
* 함수명(add) : 함수 맴체 내부에서 재귀적으로 호출하거나, 디버거의 브레이크 포인트로 사용된다. <b> 함수명이 없을 수도 있다. 이를 익명함수</b>라고 한다. 
* 매개변수 리스트 (x,y) : 매개변수 타입을 기술하지 않는다.
* 함수 몸체 ({~}) : 실제 함수가 호출됐을 때 실행되는 부분이다.

<h5>[4.1.2] 함수 선언문 방식</h5>
<p> 함수 선언문 방식은 위의 리터럴 방식과 같다. <b> 하지만 항상 함수 이름이 정의되어 있어야한다.</b> </p>

<h5>[4.1.3] 함수 표현 방식</h5>
<p> JS에서 함수도 하나의 값처럼 취급된다. 이러한 특징 덕분에 함수도 숫자나 문자열처럼 변수에 할당하는 것이 가능하다. 이런 방식으로 함수 리터럴로 하나의 함수를 만들고, 여기서 생성된 함수를 변수에 할당하여 함수를 생성하는 것을 함수 표현식이라고 한다. </p>

```
var add = function(x,y) {
    return x + y;
};

var plus = add;

console.log(add(3,5)); // 출력값 8
console.log(plus(3,5)); // 출력값 8

```

<p> 여기서 주의할 점은 <b>add가 함수 이름이 아닌 함수 변수</b>라는 것이다. <br>
  따라서 함수변수 add는 함수 객체를 할당받았고, 객체는 참조값을 갖는 것이므로 함수변수 add는 함수의 참조값을 할당 받은 것이다. 그러므로 변수 plus에 add를 할당하는 것은 두 변수가 동일한 함수의 참조값을 갖는다는 것을 의미한다. </p>

(
관련된 내용은 (3.3)참조 타입의 특성에서 확인할 수 있다. 
[(3.3)참조 타입의 특성](https://github.com/jts8257/Inside_JS/blob/main/%EC%B0%B8%EC%A1%B0_%EA%B0%9D%EC%B2%B4.md#33%EC%B0%B8%EC%A1%B0-%ED%83%80%EC%9E%85%EC%9D%98-%ED%8A%B9%EC%84%B1)
)

<p> add가 함수 이름이 아닌 함수 변수이기 때문에 add에 할당된 함수는 이름이 없다. 즉. add는 익명함수를 참조하고 있다. 
  이러한 방식을 <b>익명 함수를 이용한 함수 표현식 방법(익명 함수 표현식)</b> 이라고 한다. </p> 
<p> 반대로 함수 표현 방식에서 함수에 이름을 주는 <b>기명 함수 표현식</b> 방법이 있다. </p>

```
var add = function sum(x,y) {
    return x + y;
 };
 
 console.log(add(3,4)); // 출력값: 7
 console.log(sum(3,4)); // 출력값: Uncaughr ReferenceError: sum is not defined
 ```
 <p> 기명 함수 표현식을 이용할때 주의할 사항이 있는데, 함수이름 자체를 호출할 경우 정의되어 있지 않다는 에러가 발생한다는 것이다. 이는 함수 표현식에서 사용된 함수 이름이 외부 코드에서 접근이 불가능하기 때문이다. <br>
하지만 함수표현식 내부에서 재귀적으로 호출하거나, 디버깅시 브레이크 포인트로는 활용될 수 있다.</p>

<p> 그런데 함수 리터럴 방식에서 구현된 add() 함수는 함수 이름을 이용해서 함수를 호출했다. 어떻게 그게 가능한 것일까?
  이는, 함수 리터럴 방식으로 함수를 구현할 경우 JS엔진이 아래와 같이 변형하기 때문이다. </p>
  
```
// 함수 리터럴 방식
function add(x,y) {
       return x + y;
}

// JS엔진의 변형
var add = function add(x,y) {
    return x + y;
};
```

<h5>[4.1.3.1] 함수 선언문과 함수 표현식에서의 세미콜론</h5>
<p> JS는 C와 달리 세미콜론을 강제하지 않는다. JS엔진이 자동으로 세미콜론을 삽입해주기 때문이다. <br>
  이러한 이유로 함수 선언문(리터럴)방식에서 함수를 선언할때 마지막에 세미콜론(;)을 붙이지 않았지만, 함수 표현방식을 이용할 경우 마지막에 세미콜론을 붙인것에 대해서 크게 생각하지 않을 수 있다. <b> 하지만 세미콜론을 신경쓰지 않는다면 심각한 디버깅 상황에 직면할 수 있다.</b> 그리고 이러한 디버깅을 막기위해 <b> 함수 표현식에는 세미콜론을 직접 붙이는 것이 강력하게 권고되고 있다.</b> </p>
  
<h5>[4.1.4] Function() 생성자 </h5>
<p> 앞선 함수 선언문, 함수 표현식 모두 내부적으로는 Function() 생성자 함수를 활용해서 함수를 생성한다. 따라서 함수는 Function() 기본 내장 생성자 함수로부터 생성된 객체이다.<br>
  Function() 생성자 함수의 문법은 다음과 같다. </p>
  
```
new Function (arg1, arg2, ...argN, functionBody)
  - arg1, arg2, ....argN : 함수의 매개변수
  - functionBody : 함수가 호출될 때 실행될 코드를 포함한 문자열
```
<p> 이를 활용하면 </p>

```
var add = new Function('x', 'y', 'return x + y');
console.log(add(3,4)); // 출력값 7
```
 
<p> 하지만 일반적으로 생성자 함수를 이용한 함수 생성 방법은 자주 사용되지 않는다. 소스코들르 분석할때 나오는 경우가 있으므로, 상식 수준으로 알아두도록 하자. </p>


<h5>[4.1.5] 함수 호이스팅 </h5>
<p> 함수 선언문, 함수 표현식, 함수 생성자 함수를 알아보았다. 주로 사용되는 것은 선언문과 표현식인데, 이 둘은 동작 방식에서 약간의 차이가 있다. 그중의 하나가 함수 호이스팅(Function Hoisting) 이다.</p>

<p> 함수 선언문의 함수 호이스팅 </p>

```
add(2,3); // 5

function add (x,y) {
    return x + y;
}

add(4,3); // 7
```

<p> 함수 선언문 방식의 경우 add 함수가 정의되기 이전에 활용한 add가 값을 반환하고 있음을 알 수 있다. 이러한 현상을 함수 호이스팅이라고 부르는데, <b> 함수 선언문 형태로 정의한 함수의 유효 범위는 코드의 맨 처음부터 시작된다</b>는 것을 의미한다. </p>

<p> 이러한 함수 호이스팅 현상은 함수를 사용하기 전에 반드이 선언해야 한다는 규칙을 무시하므로 코드의 구조를 어성하게 만들 수도 있다. 이러한 이유에서 함수 호이스팅 현상이 없는 표현식 방식이 권고되도 있다. </p>

<p> 이러한 함수 호이스팅 현상이 일어나는 원인은 JS에서 변수 생성(Instantiation)과 초기화(Initialization)작업이 분리되어 일어나기 때문이다. 자세한 내용은 5장에서 다룬다. </p>
